/*
ПЕРЕМЕННЫЕ И ТИПЫ ДАННЫХ
В программировании очень широко используется память.Когда говорят о пямяти имеют в виду оперативную память.
Именно в неё загружаются программы для выполнения, берутся исходные данные для выполнения программы.Именно в память записываются результаты выполнения любой программы.
Простейшим способом для программиста использовать память являются переменные.
Переменная(variable) - именованная область памяти содержимое которой может изменяться в процессе выполнения программы.
Прежде чем использовать переменную её нужно объявить(создать).
Для объявления переменной нужно указать её тип и имя следующим образом(type name;)
type - тип переменной, определяет 3 вещи: 1) сколько памяти будет занимать переменная 2) какие значения она сможет принимать 3) какие операции над ней можно выполнять
Все типы данных в языке C++ можно разделить на 3 категории:
1) Логические типы(bool) занимает 1 байт памяти и принимает одно из двух значений true / false(1 / 0 соответственно).На самом деле false - 0, а true всё кроме 0.
Любую логическую переменную / выражение всегда можно интерпретировать как вопрос на который можно однозначно ответить да или нет.
2) Символьные типы(char) занимает 1 байт памяти и содержит символ в кодировке ASCII всего символов 256 переменная хранит 1 из 256 символов.
3) Числовые типы делятся на целочисленные и вещественные.
Целочисленные предназначены для хранения целых чисел а вещественные для хранения дробных чисел(чисел с плавающей запятой).
В свою очередь целочисленные типы делятся на :
1) беззнаковые(unsigned) могут хранить лишь положительные целые числа.
2) знаковые(signed) могут хранить как положительные так и отрицательные целые числа.
----------------------------------------------
К ЦЕЛОЧИСЛЕННЫЕ short(2 байта), long(4 байта), int(2 - 4 байта), long long(8 байт).
Переменная типа short принимает значение в диапозоне unsigned short(0 - 65535(2 ^ 16 - 1)вычитаем 1 потому что считаем с 0).
Переменная типа short принимает значение в диапозоне signed short(-32768 - 32767 / -2 ^ 15 - 2 ^ 15 - 1).
Все биты являются значащими(имеют модуль числа) старший бит становится знаковым и для хранения модуля остаётся на 1 бит меньше sign : 0 - "+" 1 - "-".
Переменная типа диапозон принимаемых значений unsigned long(0 - 4294967295(2 ^ 32 - 1)).
Переменная типа лонг диапозон принимаемых значений signed long(-2147483648 - 2147483647 / -2 ^ 31 - 2 ^ 31 - 1).
Переменная типа лонг диапозон принимаемых значений unsigned int может быть не меньше чем short и не больше чем long в visual studio int всегда занимает 4 байта.
В visual studio int всегда занимает 4 байта следовательно = long.
По умолчанию все целочисленные типы знаковые то есть если просто объявить типа int то она сможет хранить как положительные так и отрицательные числа.
Для объявления беззнаковой переменной перед её объявлением нужно написать ключевое слово unsigned и эта переменная сможет хранить только + целые числа.
Размер любого типа данных или значения всегда можно узнать sizeof.
Оператор возвращает размер типа или значения в байтах.
Минимальное и Максимальное значение можно узнать при помощи макроопределений.
-----------------------------------------------
ВЕЩЕСТВЕННЫЕ ТИПЫ
Предназначены для хранения дробных чисел или же чисел с плавающей запятой.
1) float 2) double.
1) Вещественное число одинарной точности занимает 4 байта.
2) Вещественное число двойной точности занимает 8 байт.
Целое и дробное число всегда раздеделяются с помощью точки а не запятой.
float может хранить до 38 знаков после запятой при этом отображается только 7 знаков.
double может хранить до 308 знаков после запятой при этом отображается только 15.
Вещестенные типы могут хранить очень большие и очень маленькие числа но эти числа часто являются не точными а приблизительными из за особеностей хранения дробных чисел в памяти
имя переменной
Нужно для того чтобы к ней можно было обращаться.
В процессе компиляции имена переменных преобразуются в адреса памяти.
Для именования переменных используются идентификаторы составленные по определённым правилам.
Идентификатор(Identifier) - имя.
-------------------------------------------
ПРАВИЛА ИМЕННОВАНИЯ ПЕРЕМЕННЫХ.
1) Имя переменной может состоять из символов латинского алфавита как строчных так и заглавных, сиволов - цифр, символа - подчёркивания.
2) Имя переменной никогда не может начинаться символом - цифрой.
3) Имена переменных регистрозависимы.
4) Для именования переменных нельзя использовать ключевые слова языка C++.
Имя переменной должно быть осмысленным.По имени переменной должно быть понятно что в ней хранится.
----------------------------------------------
КОНСТАНТЫ
Константа - именованная область памяти содержимое которой не может меняться в процессе выполнения программы.
Из переменной очень легко сделать константу для этого перед её объявлением нужно написать ключевое слово const.
Все символы имени константы должны быть заглавными.
Кромсе именованных констант существуют числовые, символьные и строковые константы.
Числовая константа это просто число в исходном коде программы.
-----------------------------------------------
СИМВОЛЬНЫЕ КОНСТАНТЫ
Символьная константа - это одиночный символ заключённый в одинарные ковычки.Всегда типа char.
Строковая константа.
Строковая константа - последовательность символов заключённая в двойные ковычки.
В конце этой последовательности всегда есть терменирующий 0.
Поэтому строковая константа всегда занимает на 1 байт больше чем содержит символов.
------------------------------------------------
ИНИЦИМАЛИЗАЦИЯ
При объявлении переменной для неё просто выделяется память.Возможно ранее в этой памяти что то хранилось - неизвестное для нас значение.
Такие неизвестные значения называют мусором.
При обращении к такой переменной возникает ошибка на этапе компиляции(C4700 uninitialized local variable).
Или ошибка на этапе выполнения(Run - Time Check Failure #3).
Для того чтобы убрать из переменной мусор её нужно проинициализировать.
Инициализация - присвоение начального значения.
Инициализацию можно выполнить при объявлении переменной либо же после объявления.
Инициализацию так же можно выполнить вводом с клавиатуры(cin >> speed;)
Инициализация - в переменную в 1 раз что то записывается неважно каким образом важно что это происходит в 1 раз.
Именно 1 запись удаляет из этой переменной мусор и даёт ей осмысленное значение в контексте нашей программы.
--------------------------------------------------
ОПЕРАТОРЫ C++.
Программа на C++ состоит из выражений.
Выражения(expression) - синтаксическая конструкция которая состоит из операндов и операторов.
Операнды - объекты над которыми выполняется какое то действие.
В качестве операндов выступают переменные и константы.
Операторы - объекты которые показывают какое именно действие нужно выполнить над операндами.
Операторы обозначаются  или 2 специальными символами.
-----------------------------------------------------
ОПЕРАТОРЫ БЫВАЮТ:
1) Унарные: Выполняют действие над 1 операндом.
2) Бинарные: Могут работать только с 2 операндами.
3) Тернарные: Работают с 3 операндами.
В C++ есть всего 1 тернарный оператор.
*/
/*
Все операторы можно разделить на категории
1 - Арефмитические операторы (Arithmatical_Operators)
	//Unary: + -
	//Binary: + - * / %
	// % - остаток от деления
	_________________________________________________________________________________
операция остаток от деления не приминимо к вещ типом данных float double
Если делимое меньше делителя то оно полностью выподает в остаток
ОПЕРАТОР ОСТАТОК ОТ ДЕЛЕНИЯ ОЧЕНЬ ЧАСТО ИСПОЛЬЗУЕТСЯ ЧТОБЫ ПОЛУЧИТЬ РАЗРЯДЫ ЧИСЛА
Младший разряд десятичного числа это остаток от деления на 10
Младший рязряд двоичного числа это остаток от деления на 2
Впростейшем случае выражение справа r-value состоит из одной перемнной или констаннты хотя может быть песконечно сложным
у оператора присвоить оченоь низкий приоритет и ассациативность с права на лево
ассациотивность включается тогда когда выражение состоит из операторов с одинаковым приоритетом
Ассоциотивность может быть с лева на право или с права на лево
У всех опенраторов ассоц с лева на право кроме присваиваний у присваиваний  всегда ассоц с права на лево
______________________________________________________________
3 - INCREMENT_DECREMENT - (++/--)
// Increment(++) - унарный оператор который увеличивает значение переменной на 1.
// Decrement(--) - унарный оператор который уменьшает значение переменной на 1.
// У них есть 2 формы записи:
// 1) Префиксная.
// В ней оператор пишется перед оператором.
// 2) Постфиксная
// В ней оператор пишется после оператора.
------------------------------------------------------
4 - Префиксная и постфиксная декримента и энкремента
Отличаются приоритетом по сравнению с другими операторами
У префиксной формы записи приоритет выше чем у других операторов
У постфексной ниже чем у других операторов
---------------------------------------------------------
У префиксной формы записи самый высокий приоритет
У постфиксной самый низкий даже ниже чем у присваивания
-------------------------------------------------------
5 - Составные присваивания COMPOUND_ASSIGMENTS
Если переменну нужно уменьшить не на единицу а на другое значение или же в несколько раз
Используются составные присваивания // +=,-+,*=,/+,%=;
Составные присваивания упростить выражения вида a = a + b;
Выражения в которых есть операторы сравнения еще называют логическими выражениями
Операторы сравнения испольхуются в написании условия
Условие состоящее из одной операции сравнения называют простым
Простые условия при помощи логических операторов
------------------------------------------------------------
6 - ЛОГИЧЕСКИЕ ОПЕРАТОРЫ ()
3 ЛОГИЧЕСКИХ ОПЕРАТОРА
! - NOT - унарный оператор, который отрицает условие. (!true == false)
!! - OR - результатом сложного условия будет true если результат хотябы одного простого усовия true.
&& - AND - результатом сложного условия будет false если результат хотябы одного простого условия false
Все остальные логические операторы бинарные
-----------------------------------------------------------
Управляющии структуры (Control structures)
Часто возникает необходимость сделать выбор того какая часть кода будет выполнена или
же много кратно выполнить определенную часть кода
Для этого в любом языке прормирования есть управл. структуры
Они делятся на констр витвления и циклы
Конструк. витвления относятся if...else...switch
К циклам относятся while...do while...for...
-----------------------------------------------------------
Констр выбора if...else
Констр if
выберает один из двух вариантов кода в зависимости от условия
У констр if след интаксис
if(Condition)
{
	 ...;
	 code1;
	 ...;
}
else
{
	...;
	code2;
	...;
}

Condition - это условие.
Условие - это операция сравнения.
Условие может быть простым состаящим из одной операции сравнения
Так и сложним обьединеным с логич операторами
&& - AND
|| - OR
Если условие вернуло True
То выполняется код 1 и после его выполнения блок else и код 2 игнорируется
Есле же условие вернуло false тогда игнорируется код 1 а выполнения выходят за пределы блока if и выполняется блок else если он есть
Блок else и код 2 я вляются не обязателями элементами конструкции
После ключ условия else условие не предусмотрено и если его написать будет синтакс ошибка
Если есть необходимость написать условия после ключ слова else
То после else сразу пишется if а потом пишется условие
Это позволяет обьединить несколько конструкций if...else в одну цепочку
У такой цепочки след синтакс
if(Condition1)
{

	code1;

}
else if(ConditionN)
{
	codeN;
}
else
{

	default code;

}
Условия проверяются последовательно. Если условие вернуло true(1) то выполняется соответствующий код.
После выполнения кода все последующие не проверяются.
В такой цепочке очень важен порядок написания условий.
При неправильном расположении некоторые условия могут даже не проверяться.
----------------------------------------------------------
Конструкция множественного выбора switch
В отличии от if которая выберает один из двух вариантов кода взависимоти от условия
В switch выберает один из множества вариантов кода взависимоти от значения некоторой переменной
У конструкции switch
switch (var)
{
case CONST_1: ...code1...; break;
case CONST_2: ...code2...; break;
.................................
.................................
case CONST_N: ...codeN...; break;
default: Default Code;
}
Var-variable-переменная по значению каторой switch выберает каакой вариант кода нужно выполнить
Эту переменную он последоавательно сравнивает с константами конст1 конст2 и дт
И присовпадении выполняет соотвецтвующий code1 code2 и тд до ключ слова break
Ключ слово break прирывает выполнение кода и выход за пределы конструкции switch
Если ключ слово break отсуцтвует то выполнит код соотвецтвующий след кейсу и тд
Пока не встретится break или не закончится switch
Если переменная var не совпала ни с одной констант то выпролнится код после метки default если она есть
Метка defolt and defolt code они необязательны для switch
Переменная var и константы const1,const2 and constN могут быть только целочисленного либо символьного типа
Все остальные типы данных switch не понимает
------------------------------------------------------------------------
ЦИКЛЫ
Циклы - это кправ структ которые позволяют многократно выполнить определенный код.
Тоесть зациклить выполнение заданного участка кода
В С++ существуют всего 3 цикла
while - цикд пред условия
do...while - цикл с постусловием
for - цикл на заданное число итераций
while and do...while имеют следующий синтаксис

while (Condition)                         do
{											{
	  group - of - statements; // Тело			group - of - statements; //Тело
цикла.										цикла.


}											} while (Condidtion);
Циклы while and do...while отличаются тем что while сначало проверяет условие а за тем выполняет тело цикла
А do...while сначало выполняет тело цикла а потом проверяет его
Если условие вернуло True то тело цикла выполняется еще раз тоесть у цикла do...while тело цикла
Будет выполнено хотя бы один раз не зависимо от условия
Тем времиенем do...while если при проверки условие вернуло false то тело цикла выполнит ни разу.
Цикл do...while сначало делает а потом думает.
Итерация - однокатное выполнение тела цикла.
Тело цикла - код который нужно зациклить (многократно выполнить)
Функция getch ожидает нажатие клавиши и возвращяет ASCII-КОД нажатой клавиши.
Функция _getch() находится в библеотеке conio.h
FOR - это цикл на заданное число итераций
У цикла for(counter; condition; expression)
		{
			....;
			group-of-statements;
			....;
		}
Counter - счетчик цыкла эта переменная которая считает скоко раз выполнился или скоко раз будет выполнен цикл
Эта переменная может быть обьявлена в самом цикле for на месте выражения counter так и перед ним
Если счетчик обьявлен в самом fore на месте counter то он является локальным для этого цикла и существует только в этом fore
И только в его области видимости область видимости for ограничивается его (),{}
Локальные счетчики всегда удаляются из памяти по завершению всех итераций у того цикла которого они обьявлены
Глоббальный счетчик (обьявленный перед фором будет суц и после фора а цикл только изменит его)
выражение коунтер отрабатывает один раз перед первой итерацией
Condition - это условие продолжения или завершения цикла в этом усовии как правило счетчик сравнивается с какимто значением если условие вернуло true тело цыкла выполняется если false то происходит выход за пределы цикла
Условие проверяется после каждой итерацией.
Expression - это выражение которое изменяет счетчик в этом выражении как правило пишут инкримент и декремент счетчика хотя сдесь можно писать все что угодно
Выполняет после каждой итерации
Group-of-statements - это тело цикла сдесь можно писать все что угодно из языка с++

Тернарный оператор возвращает одно из двух значений взависимости от условия
Если условие вернулo True то выберает value 1
Если же False то выберает value 2
Value должны быть одинакового







Ternary в отличается от if тем что он возвращает значение
что и делает его оператором и благодоря чему Ternary  в отличается от if можно сделать частью выражения
--------------------------------------------------------------------------
массив(Array)-это набор переменных одного типа в непрерывной области памяти
массив создают всякий раз когда нужно обьявить много переменных одного тип
Массивы бывают статические и динамические
Кол-во элементов статического массива может быть заданно целочисленным константным только во время написания исходного кода
колв-во элементов статического массива не может быть изменено после компиляции.
Кол-во элементов динамического массива может быть задан переменным значение во время выполнения программы
Как стат и дем массивы одномерные двухмерные трехмерные и т.д
Кол-во измерения массива ни как не ограничевается компилятором
Пока мы будем работать с одномерными и только статическими массивами
--------------------------------------------------------------------------
ОБЬЯВЛЕНИЕ МАССИВА
				type name[SIZE];
type - тип элементов массива.
Элементы массива могут быть любого существ. типа
name - имя массива. Для именования массивов используются такие же идентификаторы как и для именования переменных.
SIZE - количество элементов массива может быть задано лишь целочисленным константным значением
Пример обьявления массива
		const int n=5;
		int arr[n];
---------------------------------------------------------------------------
ОБРАЖЕНИЕ К ЭЛЕМЕНТАМ МАССИВА
Для ображения к элементу массива необходимо указать его номер в квадратных скобках после имени массива
например arr[1] = 123;
Элементы массива нумеруются с 0 и именно по этому номер последнего массива всегда на 1 ед меньше кол-во элементов
Тоесть в массиве из пяти элементов всегджа отсуцтвует пятый элемент
Для обращения к элементам массива очень удобно использовать цикл for
Поскольку у него есть счетчик i который очень удобно использовать для нумерации элементов
---------------------------------------------------------------------------
ИНИЦИАЛИЗАЦИЯ МАССИВОВ
Для инициализации массива необходимо перечислить значение его элементов через запитую в фигуро скобках
--------------------------------------------------------------------------------------
ФУНКЦИИ
Функция - это именнованая последовательность выражений С++ риализующая определенный алгоритм
Возведение числа в степень извлеч квадратного корня вывод массива на экран
Сумирования элементов массива запись данных в файл загрузка данных из файла и т.д
Функци позволяют уменьшить обьем исходного кода за счет повторного использования кода а также функции
дела.т код более логичным и понятным позволяют исходные коды одной программы хранить в несккольких исходных файлах
и использовать в других проектах кроме того
Функции помогают организовать в разработке над одним исходным кодом
Прежде чем использовать функцию ее нужно обьявить и написать

синтаксмис написания функции выглядет след образом
type name(parameters)
{
	......;
	group-of-statements;
	......;
}
 type - тип возвращаемого значения.
 Любая функция по зовершению возвращает какоето значения результат своей работы.
 У любого значения в языке С++ есть тип вот этот тип и указывается при написании функции.
 Функция может возвращять значение любого сущ. типа.
 Некоторые функции ничего не возвращают поскольку их результат и так виден
 Напиример если функция выводит чтото на экран заполняет массив и фильтрует его.
 Тип возвращ. типа функции будет void - пустота.
 Если тип возвращ. значения функции отличается от void
 то в ее теле обязательно должно быть написанано return value; (возвращаемое значение.)
 Ключевое слово return прерывает работу функции возвращает значение и возвращает управление на место вызова
 Void функциях ключ слово return писать необязательно но его можно использовать для того чтобы прервать работу функции
 Ключ слово return может вернуть не более 1-го значения один return не может вернуть 2 или более значений
----------------------------------------------------------------------------------
NAME - имя функции.
Для именования функции используются идентификаторы как и для переменных
Parametrs - список принимаемых параметров1
Принимаемые параметны это исходные данные для работы функции
Принемаемые параметры представляют собой самые обычные переменные обьявленные в заголовке функции
Эти переменные являются локальными функциями которые сущ. только в ее области видемости а именно в ее круглых и фигурных скобках
Локальные переменные удаляются из памяти по завершению функции.
group-of-statements - тело функции как раз здесь написан алгоритм возложанные на функцию
В теле функции можно писать все что угодно короме реализации другой функции.
------------------------------------------------------------------------------
Прототип реализация вызов
Прототип функции - это обьявления функции (Function declaration)
Срстоит только из заголовка функции и заканчивается точкой с запятой
Прототип функции нужен для что-бы имя функции ее список принимаемых параметров и тип возвращаемого значения были известны на момент вызов
Состоит из заголовка и тела функции и определяет что делает функция
В реализации функци можно писать все что угодно кроме реализации другой функции
Для того чтобы функция зароботала ее не достаточно обьявить и написать ее нужно хотябы раз вызвать.
Один раз написаная функция может быть вызвана сколько угодно раз это и открывает возможности повторного использования кода
Любой код мы можем написать один раз в любой функции и потом вызывать эту функцию столько раз сколько это нужно
Именно это свойство и позволяет уменьшить обьем кода именно это и называется повторным использованием кода
В других языках программирования называют (процедурами или подпрограммами)
------------------------------------------------------------------------------------
ПРИНИМАЕМЫ И ПЕРЕДАВАЕМЫЕ ПАРАМЕТРЫ
Когда мы пишем прототи или реализацию функции
Когда вызываем функцию то передаем в нее данные
В функцию можно передать столько параметров сколько она позволяет в плохом случае она выдаст ошибку в процессе компиляции
если передать меньше данных чем она принимает(Too few arguments in function call)
если передать в нее больше параметров чем она принимает (too many argument in function call)
Влюбом случае возникает ошибка на этапе компиляции (Function doesn't take N arguments)
Но все таки есть способ передать в функцию меньше параметров благодаря параметрам поумолчаям
Реализация функции - определение функции. Определяет что делает функция.
---------------------------------------------------------------------------------------
ПАРАМЕТРЫ ПОУМОЧАНИЮ (Default Arguments)
Default Arguments - это параметры у которых есть значения по умочанию
Параметры по умолчанию могут быть заданы только в прототипе функции в противном случае возникает ошибка на этапе компиляции
"FillRand":redefinition of default argument: parameter 1
--------------------------------------------------------------------------------------
UNRESOLVED EXTERNALS
LNK1120 Unresolved externals - возникает в том случае когда список принимаемых параметров после реализации прототипе реализации отсуцтвует
---------------------------------------------------------------------------------------
Перегрузка функции
Перегрузкой функций называется ситуация когда есть две и полее функций с одинаковым списком принимаемых параметров.
Список принимаемых параметров перегруженых функций может отличаться типо так и кол-во элементов.
Реализацией перегруженных функций также могут отличаться или могут быть идентичными.
Как правило если список принимаемых параметров перегруженых функций лишь отличается то и реализации у них будут идентичны или как минимум будут похожи
но если список принимаемых параметров отличчается кол-во аргументов то скорее всего их реализации у них будут разные
Тип возвращаемого значения перегруж функций также может отличатьмся но перегруж функции не могут отличаться лишь типом возвращаемого значением
Поскольку коимпилятор определяет какой экземпляр перегруженой функции неужно вызвать именно по списку принимаемых параметров
А не по возвращаемому значению.
-----------------------------------------------------------------------------------------
Система контроля версий
Они нужны для сохранения промежуточных вариантов исходного кода также для организации командной работы над одним исходным кодом
Существует много контрол версий VCS - Version Control System
Subversion, SVN, Mercury.........,
Git она позволяет использовать площадку GitHub.
Следует понимать что Git and GitHub это не одно и тоже
Git - это систеиап контроля версий
GitHub - это облочное хранилище для исходных кодов
Ключеввым понятием контроля верий является
Repository - это хранилище исходных кодов
Кроме исх.кодов в репозитории таже можно хранить графические файлы простые текстовые файлы звуовые и видео файлы и вообще все что угодно
Это самая обычная папка данных которые состояние следит контроль версий
Различают локальный и удаленный репозетории
Локальный репозиторий хрянащиеся на пк разработчика
Удаленные на сервере или же GitHub
Локальные и удаленные должны быть связаны и синхронизироваться
Для синхронизации используют команды: fetch,pull,push
След понятие любой VCS является commit
commit - контрол точка в которой сохраняется текущее состояние всех необходимы данных в репозитории
Его нужно создавать всякий раз когда мы хотим сохранить важнеые изменения в нашем исходном коде
И иметь возможность вернуться к ним в любой момент
След понятием любой системой контроля версий является ветка
Ветка это послед. комитов ветки создают для того чтобы было две разные версии одного и того исходного кода.
--------------------------------------------------------------------------------------
Шаблоны функций
Шаблонной называется функция - которая может работать с любым типом данных
Для того чтобы сделать функцию шаблонной переднефй нужно сделать

template<typename T>
Теперь любой приним параметр локальная переменная и возвр значения функция может быть шаблонного типа T
Созданный шаблон существует только до точки с запятой в прототипе либо до закрывающей фигур скобки в реализации
Таким образом шаблон действует только на одну функцию одним шаблоном нельзя шаблонизировать две и более функции
------------------------------------------------------------------------------------------
Указатели
Часто возникает необходимость вместо значения переменной узнать адрес этой переменной.
Для работы с адресами в языке с++ есть указатели
Указатель (Pointer) - переменная которая содержит адрес
Адрес это число длинной 4 байта означ. порядковый номер байта в оперативной памяти.
Для процессора память это массив байт у каждого элемента массива есть номер этот номер и является адресом байта
Адреса всегда записывают в 16-ричной системе исчесления
Прежде чем использовать указатель его нужно обьявить
Указатели обьявляются следующим опразом
int a = 2;
int* pa = &a;
Для понимания указателей дстаточно понимать всего двух операторов
------------------------------------------------------------------------
& - Address-of operator (оператор взятия адресов) - это унарный оператор
который возвращает адрес своего аперанда.
У этого оператора есть лиш префиксная форма записи
* - оператор разыминования (Dereference operator) - это унарный оператор который возвращает значение по адресу.
* только при обьявлении указателя звездочка показывает что обьявляемая переменная указатель
* Во всех остальных случаях звездочка разминовывает указатель и возвращает значение по адресу
*
------------------------------------------------------------------------
Указатели и массивы
Имя массива якляется указателем на массив поскольку содержи адрес нулевого элемента массива
Следовательно и всего массива
Это легко проверить
const int n = 5;
int arr[n] = {3,5,8,13,21};
cout << arr << endl;
----------------------------------------------------------------------------
Арифметика указателей - к указателям можно применять следующие арифметические операторы
И результат операции будет зависить от того сколько байтов занимает целевой тип данных
--------------------------------------------------------------------------------
+
-
++
--
char*	1
shor*	2
int*	4
double*	8
---------------------------------------------------------------------------------
Передача параметров в функцию
Существует всенго 3 способа передать параметры в функцию
1.По значению - by value;
2.По указателю - by pointer;
3.По ссылке - by reference;
Все время до этого мы передавали параметры в функцию по значению
При этом значение передаваемых параметров копируюется в функцию при ее вызове
И если функция изменяет принятые значения то все изменения происходят с копиями передаемых переменных
При этом сами переданные переменные неизменны поскольку изменяются копии.
*/